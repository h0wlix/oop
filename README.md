## Паттерн **"Стратегия"**

### Решаемые задачи:

### **1. Динамическое определение действия с пивом**

**Проблема:**  
Разные виды пива (`PaleLager`, `NoAlcoholLager`, `Stout`) требуют **разных действий** (пить, вылить, сделать соус).

**Решение через Стратегию:**  
Каждый тип пива при создании устанавливает **свою стратегию**:
- `PaleLager` → `DrinkStrategy`
- `NoAlcoholLager` → `PourOutStrategy`
- `Stout` → `MakeSauceStrategy`

Метод `PerformAction()` вызывает `Execute()` у текущей стратегии, **не зная её конкретной реализации**.

### **2. Гибкая смена поведения объекта `Beer`**

**Проблема:**  
Если в будущем потребуется изменить действие для какого-то типа пива (например, `NoAlcoholLager` **не выливать, а отдать другу**), не нужно переписывать классы пива.

**Решение через Стратегию:**  
Достаточно создать новую стратегию (например, `GiveToFriendStrategy`) и **установить её в `NoAlcoholLager`**.  
Основной код (`Beer`) **остаётся неизменным**.

### **3. Инкапсуляция алгоритмов в отдельные классы**

**Проблема:**  
Если бы все действия (`Drink`, `PourOut`, `MakeSauce`) были реализованы в одном классе `Beer`, код стал бы **громоздким и сложным для расширения**.

**Решение через Стратегию:**  
Каждое действие вынесено в **отдельный класс**:
- `DrinkStrategy`
- `PourOutStrategy`
- `MakeSauceStrategy`

## Паттерн **"Шаблонный метод"**

### Решаемые задачи:

### **1. Стандартизация алгоритма использования пива**

**Где реализовано:**  
В методе `PerformAction()` базового класса `Beer`.

**Как работает:**  
Фиксированная последовательность шагов:

```cpp
void Beer::PerformAction() {
    PrepareForAction();       // Шаг 1: Подготовка
    DoActionUsingStrategy();  // Шаг 2: Действие (стратегия)
    cout << endl;             // Шаг 3: Завершение
}
```
**Подготовка (`PrepareForAction`) включает:**
- **Вывод типа пива** (`PrintType()`)
- **Проверку алкогольности** (`CheckAlcoholContent()`)
- **Открытие бутылки** (`OpenBottle()`)

**Действие (`DoActionUsingStrategy`) делегируется стратегии** (паттерн **"Стратегия"**).

### **2. Переопределяемые шаги алгоритма**

**Где реализовано:**  
Виртуальные методы `PrintType()` и `OpenBottle()` в подклассах:
- `PaleLager`
- `NoAlcoholLager`
- `Stout`

**Примеры кастомизации:**  
Для `PaleLager`:

```cpp
void PrintType() override { cout << "PALE LAGER"; }
void OpenBottle() override { cout << "Twist-off cap opened"; }
```
### **3. Контроль над структурой алгоритма**

**Базовый класс `Beer` задаёт порядок выполнения:**  
**подготовка -> действие -> завершение**

**Подклассы:**
- **не могут изменить последовательность**, но могут:
  - **переопределить отдельные шаги** (например, `OpenBottle`)
  - **добавить свою логику**  
    *(например, особый способ открытия бутылки для `Stout`)*

### **4. Сочетание с паттерном "Стратегия"**

- **Шаблонный метод** (`PerformAction`) отвечает за **структуру процесса**
- **Стратегия** (`BeerActionStrategy`) — за **вариативное поведение**, например:
  - **пить**
  - **выливать**
  - **делать соус**
